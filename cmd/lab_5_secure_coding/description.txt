perl -e "print 'A' x 84" > x &&  set /p x=<x && level1 %x%


1) Диапазон значений типа char: -128 до 127. Чтобы получить отрицательное 
значение, необходимо старший бит установить в единицу, т.к. он отвечает
за знак.
   Решение: Например, строка длиной в 128 символов(1000 0000).
2) При вычислении выражения, содержащего переменные разных типов, результат
преобразуется к самому широкому из них, в данном случае к unsigned int. 
Поэтому нужно переполнить результат.
   Решение: 4294967294 1 2.
3) Число -1 в двоичном виде имеет представление
1111 1111 1111 1111 1111 1111 1111 1111, а так как у нас беззнаковый тип, 
то при преобразовании к unsigned int в десятичном представлении 
получим 4294967295, что больше, чем 200.
   Решение: -1.
4) Переполняем тип unsigned int. Так как здесь используется функция strtol,
то при переполнении возвращается LONG_MAX или LONG_MIN (в данном случае 
LONG_MAX), поэтому при вводе 4294967294 тип int не принимает отрицательное
значение.
   Решение: 4294967294.
5) Все статические переменные помещаются в стек программы, при этом
они находятся рядом в памяти. Символ '\0' является символом конца строки.
Он автоматически добавляется в конец, поэтому необходимо следить, чтобы
для него оставалось место. В данном примере при вводе строки длиной > 15
мы выйдем за пределы массива, и последующие символы будут записываться в
близлежащую память, тем самым изменив значение переменной a.
   Решение: строка длиной > 15.
6) Оператор sizeof() возвращает количество выделенной пямяти(в данном
случае - 256), поэтому ввод System32 будет корректным.
   Решение: System32.
7) Похожий случай, как в 5 задаче. Статические переменные находятся в 
стеке, расположены в соседних ячейках памяти. При вводе строки в 16 символов
символ конца строки записывается в соседнюю ячейку памяти, тем самым
зануляя один байт в битовом представлении числа b. Отсюда и получаем,
что b = 0xffffff00. Если длина строки будет больше, то изменятся и другие
ячейки.
   Решение: Строка длиной ровно в 16 символов.
8) Если в printf ввести форматированную строку, но не передать аргументы,
то printf будет вытягивать значения из стека.
   Решение: Вводим форматированную строку вида %x_%x_%x_... до тех пор,
пока не встретим запись 0хАААААААА(переменная t). В стеке над этой переменной
и будет лежать значение переменной i(сначала выведется значение i, а потом t).
Это значение является ответом.
9) Если длина копируемой строки больше либо равна установленному значению,
то функция strncpy копирует эти и символы и при этом не добавляет в конец
символ конца строки. Т.к. в стеке password лежит над login, то введя >= 32
символа в password(в password будет 32 символа), символ конца строки 
не добавится и password будет "перетекать" в login. Поэтому, когда
срабатывает strcat(key,password), длина password будет больше 32 и key
переполнится, и значение запишется в i. Однако длина login должна
находиться от 5 до 10, если длина будет больше, то кроме переменной i
изменится еще и адрес возврата функции check_user. 
   Решение: 5-10 символов логина, >=32 символа пароля.
10) Аргумент командной строки с индексом 0 содержит путь к 
исполняемому файлу, его длина должна быть больше 16 символов. 
После того, как цикл while отработает, значение переменной i 
будет равно 16. Массив buf в стеке лежит над переменной i, поэтому, 
обратившись к ячейке buf[16], мы выйдем за пределы массива и 
запишем 0 как раз в переменную i.
    Решение: Запускаем программу, введя полный путь, чтобы он был > 16
(cmd\lab_5_secure_coding\levels\level10.exe).
11) В данном примере в стеке вызовов над переменной saved_eip будут находится
переменная saved_ebp(4 байта) и массив buf(80 байт). Поэтому, чтобы записать
значение в переменную saved_eip, необходимо пропустить 84 байта и ввести
соответсвующее значение(0х41424344). Но, т.к. в стеке число лежит от младшего
байта к старшему, нужно вводить значение в обратном порядке, т.е. символы
\x44, \x43, \x42, \x41(DCBA).
    Решение: Вводим 84 любых символа, а затем символы DCBA.
12) При запуске программы получаем адрес функции unreachable(0x40100f).
Разбив это значение по байту, получаем символы с кодами 64, 16 и 15
соответственно @, ^P(ctrl + P) и ^O(ctrl + O). Эти байты в обратном порядке
записываются в адрес возврата main, чтобы вызвалась функция unreachable
и произошел переход на следующий уровень. На вершине стека лежит buf[80](80
байт), затем адреса вложенных кадров(4 байта) и адрес возврата функции 
main(4 байта).
    Решение: Вводим 84 любых символа, а затем символы ^O, ^P, @. 